<script lang="ts">
	import { onMount, getContext } from 'svelte';
	import { WEBUI_NAME, showSidebar, user, mobile, config } from '$lib/stores';
	import { goto } from '$app/navigation';
	import { toast } from 'svelte-sonner';
	import { WEBUI_API_BASE_URL } from '$lib/constants';
	import Tooltip from '$lib/components/common/Tooltip.svelte';
	import Sidebar from '$lib/components/icons/Sidebar.svelte';
	import Spinner from '$lib/components/common/Spinner.svelte';

	// Import Kling Lip Sync API functions
	import {
		type KlingLipSyncTask,
		type KlingLipSyncConfig,
		type KlingLipSyncGenerateRequest,
		getKlingLipSyncUserConfig,
		submitKlingLipSyncTask,
		getKlingLipSyncTaskStatus,
		getKlingLipSyncUserTaskHistory,
		getKlingLipSyncUserCredits,
		deleteKlingLipSyncTask
	} from '$lib/apis/kling-lip-sync';

	const i18n = getContext('i18n');

	let loaded = false;
	let isGenerating = false;
	let currentTask: KlingLipSyncTask | null = null;
	let generatedResult: KlingLipSyncTask | null = null;
	let taskHistory: KlingLipSyncTask[] = [];
	let userCredits = 0;
	let loadingData = false;
	let pollingInterval: NodeJS.Timeout | null = null;
	let lipSyncConfig: KlingLipSyncConfig | null = null;

	// Form data
	let videoFile: File | null = null;
	let videoUrl = '';
	let uploadedVideoUrl = '';
	let inputText = '';
	let selectedVoiceId = 'girlfriend_1_speech02';
	let selectedLanguage = 'zh';
	let inputMode: 'file' | 'url' = 'file';

	// Available voices
	let availableVoices = [
		{ id: 'girlfriend_1_speech02', name: 'å¥³å£°1 - ç”œç¾', language: 'zh', gender: 'female' },
		{ id: 'girlfriend_2_speech01', name: 'å¥³å£°2 - æ¸©æŸ”', language: 'zh', gender: 'female' },
		{ id: 'boyfriend_1_speech01', name: 'ç”·å£°1 - ç£æ€§', language: 'zh', gender: 'male' },
		{ id: 'narrator_1_speech01', name: 'æ—ç™½ - ä¸“ä¸š', language: 'zh', gender: 'neutral' }
	];

	// Available languages
	let supportedLanguages = [
		{ code: 'zh', name: 'ä¸­æ–‡' },
		{ code: 'en', name: 'English' },
		{ code: 'ja', name: 'æ—¥æœ¬èª' },
		{ code: 'ko', name: 'í•œêµ­ì–´' }
	];

	onMount(async () => {
		if ($user) {
			await loadUserData();
			await loadAvailableOptions();
			loaded = true;
		}
	});

	const loadUserData = async () => {
		if (!$user?.token) {
			console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘æ²¡æœ‰tokenï¼Œæ— æ³•åŠ è½½æ•°æ®');
			return;
		}

		try {
			loadingData = true;

			// Load configuration using API wrapper
			try {
				lipSyncConfig = await getKlingLipSyncUserConfig($user.token);
				console.log('ğŸ¤ ã€å¯¹å£å‹ã€‘é…ç½®å·²åŠ è½½:', lipSyncConfig);
			} catch (error) {
				console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘åŠ è½½é…ç½®å¤±è´¥:', error);
			}

			// Load user credits using API wrapper
			try {
				const credits = await getKlingLipSyncUserCredits($user.token);
				if (credits && credits.success) {
					userCredits = credits.balance || 0;
					console.log('ğŸ¤ ã€å¯¹å£å‹ã€‘ç§¯åˆ†ä½™é¢:', userCredits);
				}
			} catch (error) {
				console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘åŠ è½½ç§¯åˆ†å¤±è´¥:', error);
			}

			// Load task history using API wrapper
			try {
				const historyData = await getKlingLipSyncUserTaskHistory($user.token, 1, 20);
				if (historyData && historyData.data) {
					taskHistory = historyData.data;
					console.log('ğŸ¤ ã€å¯¹å£å‹ã€‘åŠ è½½å†å²è®°å½•:', taskHistory.length, 'ä¸ªä»»åŠ¡');
				}
			} catch (error) {
				console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘åŠ è½½å†å²å¤±è´¥:', error);
			}
		} catch (error) {
			console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error);
			toast.error('åŠ è½½æ•°æ®å¤±è´¥');
		} finally {
			loadingData = false;
		}
	};

	const loadAvailableOptions = async () => {
		try {
			// Load available voices
			const voicesResponse = await fetch('/api/v1/kling-lip-sync/voices', {
				method: 'GET',
				headers: {
					'Content-Type': 'application/json',
					Authorization: `Bearer ${localStorage.getItem('token')}`
				}
			});

			if (voicesResponse.ok) {
				const voicesData = await voicesResponse.json();
				availableVoices = voicesData.voices || availableVoices;
			}

			// Load supported languages
			const languagesResponse = await fetch('/api/v1/kling-lip-sync/languages', {
				method: 'GET',
				headers: {
					'Content-Type': 'application/json',
					Authorization: `Bearer ${localStorage.getItem('token')}`
				}
			});

			if (languagesResponse.ok) {
				const languagesData = await languagesResponse.json();
				supportedLanguages = languagesData.languages || supportedLanguages;
			}
		} catch (error) {
			console.error('åŠ è½½å¯ç”¨é€‰é¡¹å¤±è´¥:', error);
		}
	};

	const handleVideoUpload = async (event) => {
		const file = event.target.files[0];
		if (!file) return;

		if (!file.type.startsWith('video/')) {
			toast.error('è¯·ä¸Šä¼ è§†é¢‘æ–‡ä»¶');
			return;
		}

		if (file.size > 100 * 1024 * 1024) {
			toast.error('è§†é¢‘æ–‡ä»¶ä¸èƒ½è¶…è¿‡100MB');
			return;
		}

		try {
			// ä½¿ç”¨ç›´æ¥ fetch ä¸Šä¼ è§†é¢‘ï¼Œå› ä¸ºè¿™æ˜¯æ–‡ä»¶ä¸Šä¼ è€Œä¸æ˜¯å¯¹å£å‹ä»»åŠ¡æäº¤
			const formData = new FormData();
			formData.append('file', file);

			const response = await fetch(`${WEBUI_API_BASE_URL}/kling-lip-sync/upload-video`, {
				method: 'POST',
				headers: {
					Authorization: `Bearer ${$user?.token}`
				},
				body: formData
			});

			const result = await response.json();
			if (result.success) {
				uploadedVideoUrl = result.video_url;
				videoFile = file;
				toast.success('è§†é¢‘ä¸Šä¼ æˆåŠŸ');
				console.log('ğŸ¤ ã€å¯¹å£å‹ã€‘è§†é¢‘ä¸Šä¼ æˆåŠŸ:', uploadedVideoUrl);
			} else {
				toast.error(result.message || 'è§†é¢‘ä¸Šä¼ å¤±è´¥');
			}
		} catch (error) {
			console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘è§†é¢‘ä¸Šä¼ å¤±è´¥:', error);
			toast.error('è§†é¢‘ä¸Šä¼ å¤±è´¥');
		}
	};

	const submitLipSyncTask = async () => {
		if (!inputText.trim()) {
			toast.error('è¯·è¾“å…¥å¯¹å£å‹æ–‡æœ¬');
			return;
		}

		if (inputMode === 'file' && !videoFile) {
			toast.error('è¯·å…ˆä¸Šä¼ è§†é¢‘æ–‡ä»¶');
			return;
		}

		if (inputMode === 'url' && !videoUrl.trim()) {
			toast.error('è¯·è¾“å…¥è§†é¢‘URL');
			return;
		}

		if (!$user?.token) {
			toast.error('è¯·å…ˆç™»å½•');
			return;
		}

		try {
			isGenerating = true;

			// æ„å»ºè¯·æ±‚å‚æ•°
			const requestData: KlingLipSyncGenerateRequest = {
				audioText: inputText.trim(),
				voiceType: selectedVoiceId,
				language: selectedLanguage
			};

			// æ ¹æ®è¾“å…¥æ¨¡å¼å¤„ç†è§†é¢‘
			let videoFileToSubmit: File;
			if (inputMode === 'file') {
				videoFileToSubmit = videoFile;
			} else {
				// URL æ¨¡å¼éœ€è¦å…ˆä¸‹è½½è§†é¢‘æ–‡ä»¶
				toast.error('æš‚ä¸æ”¯æŒè§†é¢‘URLæ¨¡å¼ï¼Œè¯·ä½¿ç”¨æ–‡ä»¶ä¸Šä¼ ');
				return;
			}

			console.log('ğŸ¤ ã€å¯¹å£å‹å‰ç«¯ã€‘æäº¤å¯¹å£å‹ä»»åŠ¡:', requestData);

			// ä½¿ç”¨ API wrapper æäº¤ä»»åŠ¡
			const result = await submitKlingLipSyncTask($user.token, videoFileToSubmit, requestData);
			
			if (result && result.success) {
				currentTask = { 
					id: result.task_id, 
					status: 'submitted',
					audioText: inputText.trim(),
					voiceType: selectedVoiceId,
					language: selectedLanguage,
					progress: '0%'
				} as KlingLipSyncTask;
				toast.success('å¯¹å£å‹ä»»åŠ¡æäº¤æˆåŠŸ');
				
				// Start polling for task status
				startPolling(result.task_id);
				
				// Refresh user data
				await loadUserData();
			} else {
				toast.error(result?.message || 'ä»»åŠ¡æäº¤å¤±è´¥');
			}
		} catch (error) {
			console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘æäº¤ä»»åŠ¡å¤±è´¥:', error);
			toast.error('æäº¤ä»»åŠ¡å¤±è´¥');
		} finally {
			isGenerating = false;
		}
	};

	const startPolling = (taskId: string) => {
		if (!$user?.token) {
			console.error('ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘æ— tokenï¼Œåœæ­¢è½®è¯¢');
			return;
		}

		if (pollingInterval) {
			clearInterval(pollingInterval);
		}

		console.log('ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘å¼€å§‹è½®è¯¢ä»»åŠ¡:', taskId);
		const maxAttempts = 120; // æœ€å¤šè½®è¯¢120æ¬¡ (çº¦10åˆ†é’Ÿï¼Œ5ç§’é—´éš”)
		let attempts = 0;

		pollingInterval = setInterval(async () => {
			try {
				attempts++;
				console.log(`ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘ç¬¬${attempts}æ¬¡æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€: ${taskId}`);

				// ä½¿ç”¨ API wrapper è·å–ä»»åŠ¡çŠ¶æ€
				const taskData = await getKlingLipSyncTaskStatus($user.token, taskId);

				if (taskData) {
					console.log('ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘ä»»åŠ¡çŠ¶æ€æ›´æ–°:', {
						status: taskData.status,
						progress: taskData.progress,
						outputVideoUrl: taskData.outputVideoUrl,
						cloudVideoUrl: taskData.cloudVideoUrl
					});

					// æ›´æ–°å½“å‰ä»»åŠ¡çŠ¶æ€
					currentTask = taskData;

					// æ£€æŸ¥å®Œæˆ
					if (taskData.status === 'succeed') {
						console.log('ğŸ‰ å¯¹å£å‹ä»»åŠ¡å®Œæˆ!');
						generatedResult = taskData;
						clearInterval(pollingInterval);
						pollingInterval = null;
						toast.success('è§†é¢‘å¯¹å£å‹ç”Ÿæˆå®Œæˆ');
						await loadUserData();
						return;
					} else if (taskData.status === 'failed') {
						console.log('âŒ å¯¹å£å‹ä»»åŠ¡å¤±è´¥');
						clearInterval(pollingInterval);
						pollingInterval = null;
						toast.error('è§†é¢‘ç”Ÿæˆå¤±è´¥: ' + (taskData.failReason || 'æœªçŸ¥é”™è¯¯'));
						await loadUserData();
						return;
					}
				}

				// æ£€æŸ¥è¶…æ—¶
				if (attempts >= maxAttempts) {
					console.log('ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°ï¼Œåœæ­¢è½®è¯¢');
					if (pollingInterval) {
						clearInterval(pollingInterval);
						pollingInterval = null;
					}
					currentTask = null;
					toast.error('ä»»åŠ¡è¶…æ—¶');
					return;
				}
			} catch (error) {
				console.error('ğŸ¤ ã€å¯¹å£å‹è½®è¯¢ã€‘è½®è¯¢å‡ºé”™:', error);
			}
		}, 5000); // æ¯5ç§’è½®è¯¢ä¸€æ¬¡
	};

	const deleteTask = async (taskId: string) => {
		if (!$user?.token) {
			toast.error('è¯·å…ˆç™»å½•');
			return;
		}

		try {
			const confirmed = confirm('ç¡®å®šè¦åˆ é™¤æ­¤å¯¹å£å‹ä»»åŠ¡å—ï¼Ÿ');
			if (!confirmed) return;

			console.log('ğŸ—‘ï¸ åˆ é™¤å¯¹å£å‹ä»»åŠ¡:', taskId);

			// ä½¿ç”¨ API wrapper åˆ é™¤ä»»åŠ¡
			const result = await deleteKlingLipSyncTask($user.token, taskId);
			
			if (result && result.success) {
				// ä»å†å²è®°å½•ä¸­ç§»é™¤ä»»åŠ¡
				taskHistory = taskHistory.filter((t) => t.id !== taskId);

				// å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä»»åŠ¡ï¼Œæ¸…ç©ºå½“å‰ä»»åŠ¡çŠ¶æ€
				if (currentTask?.id === taskId) {
					currentTask = null;
					if (pollingInterval) {
						clearInterval(pollingInterval);
						pollingInterval = null;
					}
				}

				// å¦‚æœåˆ é™¤çš„æ˜¯æœ€æ–°ç”Ÿæˆç»“æœï¼Œæ¸…ç©ºæ˜¾ç¤º
				if (generatedResult?.id === taskId) {
					generatedResult = null;
				}

				toast.success('ä»»åŠ¡åˆ é™¤æˆåŠŸ');
				await loadUserData(); // åˆ·æ–°æ•°æ®
			} else {
				toast.error(result?.message || 'åˆ é™¤å¤±è´¥');
			}
		} catch (error) {
			console.error('ğŸ¤ ã€å¯¹å£å‹ã€‘åˆ é™¤ä»»åŠ¡å¤±è´¥:', error);
			toast.error('åˆ é™¤å¤±è´¥');
		}
	};

	const formatDate = (dateString) => {
		if (!dateString) return '-';
		return new Date(dateString).toLocaleString('zh-CN');
	};

	const getStatusText = (status) => {
		const statusMap = {
			submitted: 'å·²æäº¤',
			processing: 'å¤„ç†ä¸­',
			completed: 'å·²å®Œæˆ',
			failed: 'å¤±è´¥'
		};
		return statusMap[status] || status;
	};

	const getStatusColor = (status) => {
		const colorMap = {
			submitted: 'text-yellow-600',
			processing: 'text-blue-600',
			completed: 'text-green-600',
			failed: 'text-red-600'
		};
		return colorMap[status] || 'text-gray-600';
	};
</script>

<svelte:head>
	<title>è§†é¢‘å£å‹ - {$WEBUI_NAME}</title>
</svelte:head>

{#if loaded}
	<div
		class="relative flex w-full h-screen max-h-[100dvh] transition-width duration-200 ease-in-out {$showSidebar
			? 'md:max-w-[calc(100%-260px)]'
			: ''} max-w-full"
	>
		<!-- ä¸»ä½“å†…å®¹ - å·¦å³åˆ†æ ï¼šå·¦ä¾§æ“ä½œæ ï¼Œå³ä¾§å†å²è®°å½•æ  -->
		<div class="flex w-full h-full">
			<!-- å·¦ä¾§æ“ä½œæ  -->
			<div
				class="w-80 bg-gray-50 dark:bg-gray-900 border-r border-gray-200 dark:border-gray-600 overflow-y-auto scrollbar-hide"
			>
				<div class="p-4 space-y-4">
					<!-- æœåŠ¡é€‰æ‹©å’ŒçŠ¶æ€ -->
					<div>
						<h3 class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
							ğŸ¤ è§†é¢‘å£å‹æœåŠ¡
						</h3>
						<div class="rounded-lg p-3 bg-gradient-to-r from-purple-500 to-pink-600 text-white">
							<div class="flex items-center justify-between">
								<div>
									<div class="font-medium">å¯çµ AI å¯¹å£å‹</div>
									<div class="text-xs opacity-75">
										{lipSyncConfig?.enabled ? 'å·²å¯ç”¨' : 'æœªé…ç½®'}
									</div>
								</div>
								<div class="text-xl">ğŸ¤</div>
							</div>
						</div>
					</div>

					<!-- ç§¯åˆ†ä½™é¢ -->
					<div class="text-xs text-gray-600 dark:text-gray-400 space-y-1">
						<div>å½“å‰æœåŠ¡: å¯çµè§†é¢‘å¯¹å£å‹</div>
						<div>æ¶ˆè€—ç§¯åˆ†: {lipSyncConfig?.credits_per_task || 50}ç§¯åˆ†/æ¬¡</div>
						<div class="flex justify-between items-center">
							<div class="text-green-600 dark:text-green-400">ä½™é¢: {userCredits}ç§¯åˆ†</div>
							<button
								class="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 rounded transition-colors"
								on:click={async () => {
									await loadUserData();
									toast.success('é…ç½®å’Œç§¯åˆ†å·²åˆ·æ–°');
								}}
								disabled={loadingData}
								title="åˆ·æ–°ç§¯åˆ†å’Œé…ç½®"
							>
								{loadingData ? 'åˆ·æ–°ä¸­...' : 'åˆ·æ–°'}
							</button>
						</div>
					</div>

					{#if !lipSyncConfig || !lipSyncConfig.enabled}
						<div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3">
							<div class="text-sm font-medium text-red-700 dark:text-red-300 mb-1">
								æœåŠ¡æœªå¯ç”¨
							</div>
							<div class="text-xs text-red-600 dark:text-red-400">
								è¯·è”ç³»ç®¡ç†å‘˜é…ç½®å¯çµå¯¹å£å‹æœåŠ¡
							</div>
						</div>
					{:else}

					<!-- è§†é¢‘æè¿° -->
					<div>
						<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block"
							>å¯¹å£å‹æ–‡æœ¬</label
						>
						<textarea
							bind:value={inputText}
							placeholder="è¯·è¾“å…¥è¦ç”Ÿæˆå¯¹å£å‹çš„æ–‡æœ¬å†…å®¹..."
							rows="4"
							class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white resize-none"
						></textarea>
						<div class="flex justify-between items-center mt-1">
							<div class="text-xs text-gray-500">{inputText.length}/2000</div>
							<button
								on:click={submitLipSyncTask}
								disabled={isGenerating ||
									!inputText.trim() ||
									!lipSyncConfig?.enabled ||
									(inputMode === 'file' && !uploadedVideoUrl) ||
									(inputMode === 'url' && !videoUrl.trim())}
								class="px-4 py-1 bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 disabled:cursor-not-allowed text-white text-xs font-medium rounded transition-colors flex items-center gap-1"
							>
								{#if isGenerating}
									<Spinner className="size-3" />
									ç”Ÿæˆä¸­...
								{:else}
									ç”Ÿæˆå¯¹å£å‹ ({lipSyncConfig?.credits_per_task || 50}ç§¯åˆ†)
								{/if}
							</button>
						</div>
					</div>

					<!-- è¾“å…¥æ–¹å¼é€‰æ‹© -->
					<div>
						<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">è¾“å…¥æ–¹å¼</label>
						<div class="grid grid-cols-2 gap-2">
							<button
								class="px-3 py-2 text-sm rounded border transition-colors {inputMode === 'file'
									? 'bg-blue-500 text-white border-blue-500'
									: 'bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700'}"
								on:click={() => (inputMode = 'file')}
							>
								ä¸Šä¼ è§†é¢‘æ–‡ä»¶
							</button>
							<button
								class="px-3 py-2 text-sm rounded border transition-colors {inputMode === 'url'
									? 'bg-blue-500 text-white border-blue-500'
									: 'bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700'}"
								on:click={() => (inputMode = 'url')}
							>
								è§†é¢‘URL
							</button>
						</div>
					</div>

					<!-- è§†é¢‘è¾“å…¥ -->
					{#if inputMode === 'file'}
						<div>
							<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">ä¸Šä¼ è§†é¢‘</label>
							<input
								type="file"
								accept="video/*"
								on:change={handleVideoUpload}
								class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white"
							/>
							{#if videoFile}
								<div class="mt-2 text-sm text-gray-600 dark:text-gray-300">
									å·²é€‰æ‹©: {videoFile.name} ({Math.round(videoFile.size / 1024 / 1024 * 100) / 100} MB)
								</div>
							{/if}
						</div>
					{:else}
						<div>
							<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">è§†é¢‘URL</label>
							<input
								type="url"
								bind:value={videoUrl}
								placeholder="è¯·è¾“å…¥è§†é¢‘URL"
								class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white"
							/>
						</div>
					{/if}

					<!-- éŸ³è‰²é€‰æ‹© -->
					<div>
						<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">éŸ³è‰²é€‰æ‹©</label>
						<select
							bind:value={selectedVoiceId}
							class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white"
						>
							{#each availableVoices as voice}
								<option value={voice.id}>{voice.name}</option>
							{/each}
						</select>
					</div>

					<!-- è¯­è¨€é€‰æ‹© -->
					<div>
						<label class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2 block">è¯­è¨€</label>
						<select
							bind:value={selectedLanguage}
							class="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white"
						>
							{#each supportedLanguages as lang}
								<option value={lang.code}>{lang.name}</option>
							{/each}
						</select>
					</div>

					<!-- å½“å‰ä»»åŠ¡çŠ¶æ€ -->
					{#if currentTask}
						<div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
							<div class="text-sm font-medium text-blue-700 dark:text-blue-300 mb-1">å½“å‰ä»»åŠ¡çŠ¶æ€</div>
							<div class="text-sm text-blue-600 dark:text-blue-400">
								{getStatusText(currentTask.status)}
								{#if currentTask.progress}
									- {currentTask.progress}
								{/if}
							</div>
							{#if currentTask.status === 'processing'}
								<div class="mt-2">
									<div class="w-full bg-gray-200 rounded-full h-1">
										<div class="bg-blue-600 h-1 rounded-full" style="width: {currentTask.progress || '0%'}"></div>
									</div>
								</div>
							{/if}
						</div>
					{/if}

					<!-- æœ€æ–°ç”Ÿæˆç»“æœ -->
					{#if generatedResult && generatedResult.status === 'succeed'}
						<div class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-3">
							<div class="text-sm font-medium text-green-700 dark:text-green-300 mb-2">ç”Ÿæˆå®Œæˆ</div>
							{#if generatedResult.cloudVideoUrl || generatedResult.outputVideoUrl}
								<video controls class="w-full rounded-lg">
									<source src={generatedResult.cloudVideoUrl || generatedResult.outputVideoUrl} type="video/mp4" />
									æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾
								</video>
							{/if}
						</div>
					{/if}
				</div>
			</div>

			<!-- å³ä¾§å†å²è®°å½•æ  -->
			<div class="flex-1 flex flex-col bg-white dark:bg-gray-800">
				<!-- æœç´¢æ  -->
				<div class="p-4 border-b border-gray-200 dark:border-gray-600">
					<div class="flex items-center justify-between">
						<h2 class="text-xl font-semibold">ä»»åŠ¡å†å²</h2>
						<button
							on:click={loadUserData}
							class="text-blue-600 hover:text-blue-700 text-sm"
							disabled={loadingData}
						>
							{#if loadingData}
								<Spinner className="size-4" />
							{:else}
								åˆ·æ–°
							{/if}
						</button>
					</div>
				</div>

				<!-- å†å²è®°å½•åˆ—è¡¨ -->
				<div class="flex-1 p-4 overflow-y-auto scrollbar-hide">
					{#if taskHistory.length === 0}
						<div class="text-center text-gray-500 py-8">
							<div class="text-lg mb-2">æš‚æ— å†å²è®°å½•</div>
							<div class="text-sm">å¼€å§‹ä½ çš„ç¬¬ä¸€ä¸ªè§†é¢‘å£å‹ç”Ÿæˆä»»åŠ¡å§</div>
						</div>
					{:else}
						<div class="space-y-3">
							{#each taskHistory as task}
								<div class="border border-gray-200 dark:border-gray-600 rounded-lg p-4">
									<div class="flex items-center justify-between mb-2">
										<div class="text-sm {getStatusColor(task.status)} font-medium">
											{getStatusText(task.status)}
										</div>
										<div class="text-xs text-gray-500">
											{formatDate(task.createdAt)}
										</div>
									</div>
									
									{#if task.audioText}
										<div class="text-sm mb-2">
											<span class="font-medium">æ–‡æœ¬:</span> 
											<span class="text-gray-600 dark:text-gray-300">
												{task.audioText.length > 50 ? task.audioText.substring(0, 50) + '...' : task.audioText}
											</span>
										</div>
									{/if}

										{#if task.voiceType}
											<div class="text-sm mb-2">
												<span class="font-medium">éŸ³è‰²:</span> 
												<span class="text-gray-600 dark:text-gray-300">
													{availableVoices.find(v => v.id === task.voiceType)?.name || task.voiceType}
												</span>
											</div>
										{/if}

										{#if task.status === 'succeed' && (task.cloudVideoUrl || task.outputVideoUrl)}
											<div class="mt-3">
												<video controls class="w-full rounded-lg" style="max-height: 200px;">
													<source src={task.cloudVideoUrl || task.outputVideoUrl} type="video/mp4" />
													æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾
												</video>
											</div>
										{/if}

										{#if task.status === 'failed' && task.failReason}
											<div class="mt-2 text-sm text-red-600 dark:text-red-400">
												å¤±è´¥åŸå› : {task.failReason}
											</div>
										{/if}

										{#if task.status === 'succeed' || task.status === 'failed'}
											<div class="mt-3 flex justify-end">
												<button
													on:click={() => deleteTask(task.id)}
													class="text-red-600 hover:text-red-700 text-sm"
												>
													åˆ é™¤
												</button>
											</div>
										{/if}
									</div>
								{/each}
							</div>
						{/if}
					</div>
				</div>
			</div>
		{/if}
	</div>
</div>

<style>
	/* Custom styles for video elements */
	video {
		background-color: #000;
	}
</style>