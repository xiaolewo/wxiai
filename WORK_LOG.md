# WXIAI 工作记录

## 2024-08-24 积分系统优化

### 任务概述

将积分系统从小数精度改为整数精度，简化用户体验。

### 完成的修改

#### 1. 后端代码修改

- **文件**: `backend/open_webui/models/credits.py`
  - 积分字段精度: `Numeric(24,12)` → `Numeric(8,0)`
- **文件**: `backend/open_webui/utils/credit/usage.py`
  - 新增整数舍入函数 `round_credit()`
  - Token计费改为千单位进位: `math.ceil(tokens / 1000)`

#### 2. 前端代码修改

- **新建**: `src/lib/utils/credit.js` - 积分格式化工具函数
- **修改**: `src/lib/stores/index.ts` - 添加 `formatCredit()` 函数
- **修改**: `src/lib/components/chat/Settings/Credit.svelte` - 使用 `Math.round()` 显示
- **修改**: `src/lib/components/admin/Users/UserList.svelte` - 积分显示整数化
- **修改**: `src/lib/components/admin/Users/Credit.svelte` - 图表数据整数化

#### 3. 数据库迁移

- **新建**: `execute_credit_migration.py` - 数据库迁移脚本
- **执行结果**: ✅ 迁移成功，数据已备份到 `webui.db.credit_migration_backup`

#### 4. 文档更新

- **修改**: `项目架构和功能完整文档.md` - 添加积分系统优化记录

### 技术要点

- **积分精度**: 纯整数，无小数点
- **Token计费**: 1000 token = 1个计费单位
- **兼容性**: 向后兼容，现有数据自动转换
- **备份机制**: 完整数据库备份确保安全

### 部署说明

1. 代码已更新，可直接部署
2. 运行 `python execute_credit_migration.py` 执行数据迁移
3. 验证前端积分显示为整数

---

## 2024-08-24 系统清理优化

### 完成的优化

1. **清理冗余文件**: 删除49个临时测试和修复文件
2. **优化迁移管理**: 统一迁移文件命名和版本控制
3. **增强API文档**: 完善OpenAPI文档和示例
4. **性能优化**: 实施缓存策略和查询优化
5. **监控完善**: 添加业务指标监控和告警

**详细记录**: 参见 `CLEANUP_LOG.md`

---

## 工作状态

- ✅ 积分系统优化: 已完成
- ✅ 前端更新: 已完成
- ✅ 数据库迁移: 已完成
- ✅ 文档更新: 已完成

**系统状态**: 准备部署上线

---

## 2024-12-19

### 积分扣费逻辑文档

- 创建了详细的积分扣费逻辑说明文档 `对话积分扣费说明.md`
- 用通俗易懂的语言解释了以下内容：
  - 什么时候扣积分
  - 两种计费模式（Token计费和次数计费）
  - Token的概念和计算方式
  - 进位规则（千进位规则）
  - 实际计费例子
  - 节约积分的方法
- 分析了后端代码 `backend/open_webui/utils/credit/usage.py` 中的关键逻辑：
  - `CreditDeduct` 类的扣费处理流程
  - `round_credit()` 方法将积分值精确到整数
  - 进位计算：`math.ceil(tokens / 1000)` 实现千进位规则

### 修复价格显示问题

**问题描述**：用户设置按次计费后，界面显示"请求价格(TM): 1"，期望显示为"请求价格(1次):1积分"

**问题分析**：

- 定位到价格显示逻辑在 `/src/lib/components/chat/ModelSelector/ModelItem.svelte:206`
- 发现显示文本来自翻译系统：`$i18n.t('Price For 1M Requests')`
- 翻译文件中的原文本：`"Price For 1M Requests": "请求价格 (1M)"`
- 用户看到的"(TM)"实际是"(1M)"的显示问题

**解决方案**：

1. **修改翻译文件** `/src/lib/i18n/locales/zh-CN/translation.json`
   - 将 `"Price For 1M Requests": "请求价格 (1M)"` 改为 `"Price For 1M Requests": "请求价格(1次)"`

2. **修改显示逻辑** `/src/lib/components/chat/ModelSelector/ModelItem.svelte:206-209`
   - 在所有价格显示后添加积分单位：`${$i18n.t('Credit')}`
   - 请求价格显示：`请求价格(1次): 1积分`
   - Token价格显示：`提示Token价格(1M): X积分`、`响应Token价格(1M): X积分`等

3. **优化Token计费单位显示**（Token计费更符合实际千进位规则）
   - 将Token价格显示单位从"1M"改为"1K"
   - 修改翻译项：
     - `"Completion Price For 1M Tokens": "响应 Token 价格 (1K)"`
     - `"Prompt Cache Price For 1M Tokens": "缓存提示 Token 价格 (1K)"`
     - `"Prompt Price For 1M Tokens": "提示 Token 价格 (1K)"`
     - `"Unit: 1M tokens or 1M requests": "单位: 1K Tokens 或者 1 次请求"`
     - `"For 1M requests": "1 次请求的费用"`

**最终效果**：

- 按次计费模型：显示"请求价格(1次): 1积分"
- 按Token计费模型：显示"提示Token价格(1K): X积分"、"响应Token价格(1K): X积分"等
- Token计费单位更准确反映千进位规则（1000 tokens = 1个计费单位）
- 完全符合用户体验

### 定位成本详情数据结构

**问题描述**：用户提供了一个包含成本详情的数据结构示例，需要找到其在代码中的位置

**数据结构示例**：

```json
{
  "total_cost": 2,
  "cost_detail": {
    "prompt_price": 1,
    "completion_price": 1,
    "request_price": 0,
    "feature_price": 0,
    "features": [],
    "custom_fee": 0,
    "custom_fee_detail": {},
    "is_calculate": false,
    "is_error": false
  },
  "total_tokens": 147,
  "prompt_tokens": 14,
  "completion_tokens": 133,
  "prompt_tokens_details": {...},
  "completion_tokens_details": {...}
}
```

**定位结果**：

1. **主要实现位置**：`/backend/open_webui/utils/credit/usage.py:297-314`
   - `usage_with_cost` 属性方法生成此数据结构
   - 包含 `total_cost`、`cost_detail` 和所有usage相关字段

2. **数据模型定义**：`/backend/open_webui/utils/credit/models.py:15-55`
   - `CompletionUsage` 类定义了 tokens 相关字段
   - `prompt_tokens_details`、`completion_tokens_details` 等详细信息

3. **使用场景**：
   - `add_usage_to_resp()` 方法：将成本信息添加到响应中
   - `usage_message()` 方法：生成流式响应的usage消息
   - 在对话完成后返回给前端，显示本次对话的详细扣费信息

---

## 本次工作会话总结（2024-12-19）

### 工作内容概述

本次会话主要解决了WXIAI积分系统价格显示的用户体验问题，涉及前端界面显示、国际化翻译和用户期望的一致性优化。

### 主要成果

1. **成功修复价格显示问题**：将用户困惑的"请求价格(TM): 1"改为清晰的"请求价格(1次):1积分"
2. **优化Token计费单位**：将"1M"改为"1K"，更准确反映系统的千进位计费规则
3. **完善积分单位显示**：为所有价格提示添加"积分"单位，提升用户体验
4. **成功定位成本数据结构**：找到了用户查询的成本详情数据在代码中的具体实现位置

### 技术工作细节

#### 文件修改记录

- **翻译文件**：`/src/lib/i18n/locales/zh-CN/translation.json`
  - 修改5个翻译项，统一价格显示格式
  - 将Token计费单位从"1M"改为"1K"

- **组件文件**：`/src/lib/components/chat/ModelSelector/ModelItem.svelte:206-209`
  - 为价格提示添加积分单位显示
  - 优化按次计费和Token计费的显示差异

#### 关键技术发现

- 价格显示通过Svelte的国际化系统实现
- 实际计费逻辑在后端`usage.py`中实现千进位规则
- 成本详情数据结构由`usage_with_cost`属性方法生成

### 用户体验改进

- **显示一致性**：价格显示与实际计费逻辑保持一致
- **单位明确性**：明确显示"积分"单位，避免用户困惑
- **计费透明化**：准确反映1000 tokens = 1个计费单位的规则

### 工作流程规范

- 每次修改都及时记录在`WORK_LOG.md`中
- 确保代码修改与用户需求完全匹配
- 验证修改后的显示效果符合预期

### 后续建议

1. 可考虑在积分设置页面添加计费规则说明
2. 建议在用户首次使用时提供计费方式的简单引导
3. 考虑为管理员提供价格显示格式的自定义选项

### 成本详情数据结构中文化

**问题描述**：用户希望将成本详情数据结构的字段名改为中文，提升可读性

**修改内容**：

- **文件**：`/backend/open_webui/utils/credit/usage.py`
- **方法**：`usage_with_cost` 属性方法 (第297-314行)
- **存储逻辑**：数据库记录的usage字段 (第201-216行)

**字段对照表**：

```
英文字段名                 → 中文字段名
total_cost               → 总费用
cost_detail              → 费用详情
prompt_price             → 输入Token费用
completion_price         → 输出Token费用
request_price            → 请求费用
feature_price            → 功能费用
features                 → 使用功能
custom_fee               → 自定义费用
custom_fee_detail        → 自定义费用详情
is_calculate             → 是否计算
is_error                 → 是否出错
prompt_unit_price        → 输入Token单价
completion_unit_price    → 输出Token单价
request_unit_price       → 请求单价
prompt_cache_unit_price  → 缓存Token单价
```

**最终数据格式**：

```json
{
  "总费用": 2,
  "费用详情": {
    "输入Token费用": 1,
    "输出Token费用": 1,
    "请求费用": 0,
    "功能费用": 0,
    "使用功能": [],
    "自定义费用": 0,
    "自定义费用详情": {},
    "是否计算": false,
    "是否出错": false
  },
  "total_tokens": 147,
  "prompt_tokens": 14,
  "completion_tokens": 133,
  "prompt_tokens_details": {...},
  "completion_tokens_details": {...}
}
```

### 整理可灵对口型API文档

**任务描述**：整理gnwd文件夹下的可灵对口型.md文档，疏通内容结构

**原始问题**：

- 文档格式混乱，表格布局不规范
- 内容结构不清晰，缺乏层次性
- 参数说明分散，难以理解
- 缺少完整的示例和说明

**整理内容**：

1. **重新设计文档结构**
   - 添加清晰的标题层级和分隔线
   - 规范化表格格式，统一字段描述
   - 增加目录导航和接口概览

2. **梳理三个主要接口**
   - **创建任务** (POST /v1/videos/lip-sync)
   - **查询单个任务** (GET /v1/videos/lip-sync/{task_id})
   - **查询任务列表** (GET /v1/videos/lip-sync)

3. **完善参数文档**
   - 统一参数表格格式：字段、类型、必填、默认值、描述
   - 详细说明input对象的层级结构
   - 区分不同模式的参数要求
   - 添加参数约束和取值范围

4. **增加实用信息**
   - 完整的请求/响应示例
   - 重要说明和限制条件
   - 文件格式和大小限制
   - 任务状态说明
   - 回调协议说明

5. **优化用户体验**
   - 使用Markdown表格提升可读性
   - 代码块格式化JSON示例
   - 添加关键信息的醒目标注
   - 逻辑分组相关参数

**技术要点**：

- **两种模式**：text2video（文本转视频）和audio2video（音频转视频）
- **视频输入**：支持video_id或video_url二选一
- **文件限制**：视频≤100MB/2-60秒，音频≤5MB
- **任务状态**：submitted → processing → succeed/failed
- **数据保留**：生成内容30天后清理

**最终效果**：

- 文档结构清晰，易于理解和使用
- 参数说明完整，避免集成错误
- 示例代码完善，便于快速开发
- 重要限制明确标注，减少试错成本

**工作状态**：✅ 可灵对口型API文档整理完成，后端数据结构保持原样

### 完善可灵对口型API鉴权格式

**问题描述**：用户指出Authorization应该是"Bearer XXX"格式，要求参考可灵视频生成文档并完善

**参考依据**：

- 查看了`/gnwd/flux/接入教程.md`文档
- 确认正确格式为`Authorization: Bearer your-key`
- 而非之前的通用描述"鉴权信息，参考接口鉴权"

**完善内容**：

1. **更新鉴权格式说明**
   - 将所有接口的Authorization描述统一为"Bearer {your-api-key}"
   - 添加格式说明："`Bearer sk-xxx`"

2. **增加完整的cURL示例**
   - 添加了创建对口型任务的完整cURL命令
   - 包含正确的Bearer token格式
   - 提供了文本转视频和音频转视频两种模式的示例

3. **规范化请求示例**
   - JSON请求体格式化
   - 统一使用Bearer token认证
   - 确保示例的实用性和准确性

**技术改进**：

- 鉴权方式与flux API保持一致
- 提高了文档的实用性和专业性
- 便于开发者快速集成和测试

**最终效果**：

- 所有接口统一使用"Bearer {your-api-key}"格式
- 提供了完整的cURL测试示例
- 文档格式专业，便于理解和使用

**工作状态**：✅ 可灵对口型API文档鉴权格式完善完成

---

## 2024-08-24 可灵对口型功能完整设计方案

### 任务概述

根据用户需求，设计并规划可灵对口型功能的完整实施方案，包括前端页面、后端API、管理员配置、数据库迁移等全套解决方案。

### 完成的工作

#### 1. 系统架构分析

- **项目结构调研**：深入分析了WXIAI平台的完整技术架构
  - 前端：SvelteKit + TypeScript + TailwindCSS
  - 后端：FastAPI + SQLAlchemy + Alembic
  - 现有功能：可灵视频生成、积分系统、管理员配置等
- **现有功能研究**：详细分析了现有可灵视频生成的实现模式
  - API接口设计：`/src/lib/apis/kling/index.ts`
  - 页面布局：`/src/routes/(app)/videos/+page.svelte`
  - 后端路由：`/backend/open_webui/routers/kling.py`
  - 数据模型：`/backend/open_webui/models/kling.py`

#### 2. 可灵对口型API文档研究

- **API接口分析**：深入研究了`/gnwd/可灵对口型.md`文档
  - 三个核心接口：创建任务、查询单个任务、查询任务列表
  - 两种模式：text2video（文本转视频）、audio2video（音频转视频）
  - 支持video_id和video_url两种视频输入方式
  - 完整的错误处理和状态管理机制

#### 3. 完整功能设计方案

**前端设计**：

- **侧边栏扩展**：在"视频生成"下添加"视频口型"入口
- **页面布局**：左侧工作区 + 右侧历史记录，与现有视频生成页面保持一致
- **核心组件**：
  - 模式切换器（文本/音频转视频）
  - 视频输入区（支持video_id/video_url）
  - 参数配置区（音色、语速、语言等）
  - 结果展示区（实时状态和历史记录）
- **API接口层**：设计了完整的前端API客户端(`kling-lip-sync/index.ts`)

**后端设计**：

- **数据模型**：设计了3个核心表
  - `kling_lip_sync_config`：配置表
  - `kling_lip_sync_tasks`：任务表
  - `kling_lip_sync_credits`：积分记录表
- **API路由**：设计了完整的RESTful API
  - 管理员接口：配置管理、连接测试
  - 用户接口：任务提交、状态查询、历史记录
  - 积分接口：余额查询、扣费管理
- **业务逻辑**：实现了可灵API调用客户端

**管理员配置**：

- **配置页面**：`/admin/settings/kling-lip-sync/+page.svelte`
- **配置项目**：
  - 服务启用开关
  - API基础URL和密钥
  - 默认参数设置（音色、语言、语速）
  - 积分消耗配置
- **功能特性**：配置测试、实时验证、参数说明

#### 4. 数据库迁移方案

- **迁移文件**：设计了完整的Alembic迁移脚本
  - 创建3个核心表和相关索引
  - 插入默认配置数据
  - 支持升级和回滚操作
- **执行脚本**：创建了自动化迁移脚本
  - 自动备份现有数据库
  - 检查迁移必要性
  - 执行迁移并验证结果
  - 详细的状态报告和错误处理

#### 5. 完整实施文档

创建了详尽的实施方案文档：`可灵对口型功能实施方案.md`

**文档包含内容**：

- 📋 项目概述和功能目标
- 🏗️ 系统架构设计（5层架构图）
- 🎨 前端设计（侧边栏、页面、API）
- 🔧 后端设计（模型、路由、业务逻辑）
- 🗄️ 数据库迁移方案
- 🚀 部署和测试方案
- 📊 性能监控和维护
- 🎯 成功指标定义

### 技术亮点

1. **架构一致性**：完全遵循现有WXIAI平台的架构模式
2. **功能完整性**：支持可灵对口型API的所有功能
3. **用户体验**：与现有视频生成功能保持一致的界面风格
4. **安全可靠**：完整的权限控制、积分管理、错误处理
5. **可维护性**：标准化的代码结构、完善的文档、自动化脚本

### 创新设计

1. **双模式支持**：文本转语音对口型 + 音频对口型
2. **多输入方式**：支持video_id和video_url两种视频输入
3. **智能配置**：管理员可配置默认参数和积分消耗
4. **实时监控**：任务状态实时轮询和进度显示
5. **完善管理**：历史记录、筛选、删除等完整管理功能

### 实施准备

**开发工期**：预计3-5个工作日
**技术依赖**：

- 可灵对口型API访问权限
- 现有WXIAI平台环境
- 数据库迁移权限

**风险控制**：

- 完整的数据库备份机制
- 渐进式功能部署策略
- 详细的测试和验证流程

### 部署就绪性

- ✅ 完整的技术方案设计
- ✅ 详细的代码实现规范
- ✅ 自动化的迁移脚本
- ✅ 全面的测试清单
- ✅ 详尽的部署文档
- ✅ 性能监控方案

**方案状态**：📋 设计完成，可开始实施
**文档位置**：`/可灵对口型功能实施方案.md`

### 音色列表整理完善

**任务描述**：根据用户提供的音色列表，完善可灵对口型功能实施方案中的音色选择器

**处理的音色数量**：

- **中文音色**：35种，包含青少年、成年、儿童、成熟、老年、地域特色和专业音色
- **英文音色**：27种，包含青年、成年专业、儿童、成熟和特色音色

**完成的优化**：

1. **智能音色切换**：
   - 根据用户选择的语言（中文/英文）动态显示对应音色
   - 用户界面只显示音色名称，隐藏技术ID
   - 语言切换时自动切换合适的默认音色

2. **完善的音色分类**：
   - **中文音色**：从传统的"中文女声1"改为具体的"阳光少年、温柔姐姐"等富有特色的名称
   - **英文音色**：提供"Sunny、Grace、Melody"等英文名称
   - **地域特色**：包含东北、重庆、四川、潮汕等地方特色音色
   - **专业音色**：新闻播报、译制片配音等专业场景音色

3. **用户体验优化**：
   - 前端音色选择器根据语言动态更新选项列表
   - 管理员配置界面同步更新音色选择
   - 默认音色更新为真实的"genshin_vindi2"（阳光少年/Sunny）

4. **代码实现更新**：
   - 前端Svelte组件：实现语言切换联动音色选项
   - 后端数据模型：更新默认配置为真实音色ID
   - 数据库迁移：插入正确的默认音色配置
   - API接口：支持完整的音色列表传输

5. **详细音色说明文档**：
   - 新增"🎵 音色选项说明"章节
   - 按年龄、性别、特色进行详细分类
   - 每个音色都有清晰的特点描述
   - 提供音色使用建议和场景推荐

**技术特性**：

- **动态切换**：`$: currentVoiceOptions = voiceLanguage === 'zh' ? chineseVoiceOptions : englishVoiceOptions`
- **自动适配**：语言切换时自动选择对应语言的默认音色
- **用户友好**：只显示音色名称，技术ID对用户透明
- **完整支持**：前端、后端、数据库全链路支持

**最终效果**：

- 用户选择中文时看到"阳光少年、温柔姐姐"等中文音色名称
- 用户选择英文时看到"Sunny、Grace、Melody"等英文音色名称
- 语言和音色选择完全联动，用户体验流畅自然
- 提供62种丰富音色选择，满足不同场景需求

**工作状态**：✅ 音色列表整理完成，实施方案已完全更新
